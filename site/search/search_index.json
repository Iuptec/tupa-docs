{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo ao Tup\u00e3 \u26a1\ufe0f","text":"<p>O Tup\u00e3 \u00e9 um framework backend feito em Go.</p> <p>A ideia do framework \u00e9 ser f\u00e1cil e r\u00e1pido de usar para a cria\u00e7\u00e3o de aplica\u00e7\u00f5es robustas rapidamente.</p> <p>O \u00fanico requisito \u00e9 que Golang, vers\u00e3o 1.21.5 para cima esteja instalado na m\u00e1quina.</p>"},{"location":"#instalacao","title":"Instala\u00e7\u00e3o","text":"<pre><code>$ go get github.com/tupatech/tupa\n</code></pre>"},{"location":"#iniciando-um-servidor","title":"Iniciando um Servidor","text":"<p>Para iniciarmos um novo servidor, basta instanciarmos um <code>NewAPIServer(\":porta\")</code> e fazer o bootstrap da API com o m\u00e9todo <code>New()</code>. Inicialize o m\u00f3dulo na sua m\u00e1quina <code>go mod &lt;nome_modulo&gt;</code> e coloque o seguinte conte\u00fado num arquivo <code>main.go</code> </p> <pre><code>import (\n    import \"github.com/tupatech/tupa\"\n)\n\nfunc main() {\n    server := tupa.NewAPIServer(\":6969\")\n    server.New()\n}\n</code></pre> <p>Rode o servidor na m\u00e1quina <code>go run main.go</code>. No browser em <code>http://localhost:6969/</code> vamos receber a seguinte mensagem:</p> <pre><code>\"Seja bem vindo ao Tup\u00e3 framework\"\n</code></pre>"},{"location":"context/","title":"Context no Tup\u00e3","text":"<p>Voc\u00ea pode acessar o context da requisi\u00e7\u00e3o a partir da propriedade Context dentro da struct do Tupa</p>"},{"location":"context/#context-em-middlewares","title":"Context em Middlewares","text":"<p>Podemos facilmente adicionar contexto a uma requisi\u00e7\u00e3o. No Tup\u00e2 existem v\u00e1rias formas de se trabalhar com o contexto trav\u00e9s do TupaContext. Por exemplo voc\u00ea pode colocar um novo context com o m\u00e9todo <code>SetContext()</code>, que vai colocar o m\u00e9todo na requisi\u00e7\u00e3o. Para obter o valor do contexto, voc\u00ea pode obter o contexto com os m\u00e9todos <code>GetCtx()</code>, <code>CtxValue(ctx)</code>.</p> <ul> <li><code>GetCtx()</code>: retorna o context inteiro da requisi\u00e7\u00e3o</li> <li><code>CtxValue(ctx)</code>: retorna o contexto espec\u00edfico de acordo com a key especificada</li> </ul> <p>Vamos adicionar um Contexto no middleware MiddlewareSampleRoute(). Lembrando que em primeiro lugar \u00e9 chamado os middlewares especificos de rota, e s\u00f3 ent\u00e3o os globais.</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    exampleManager()\n    server.RegisterRoutes(tupa.GetRoutes())\n    server.New()\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc MiddlewareSampleCats(next tupa.APIFunc) tupa.APIFunc {\n    return func(tc *tupa.TupaContext) error {\n        return next(tc)\n    }\n}\n\nfunc MiddlewareSampleRoute(next tupa.APIFunc) tupa.APIFunc {\n    return func(tc *tupa.TupaContext) error {\n        catsCtxKey := \"ctxcats\"\n        ctxMsg := \"contexto de algu\u00e9m interessado em gatos\"\n        newCtx := context.WithValue(tc.Request().Context(), catsCtxKey, ctxMsg)\n        tc.SetContext(newCtx)\n\n        return next(tc)\n    }\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                ctxFull := tc.GetCtx()\n                fmt.Println(ctxFull)\n\n                ctxValue := tc.CtxValue(\"ctxcats\").(string)\n                fmt.Println(ctxValue)\n\n                ctxVal := tc.GetCtx().Value(\"ctxcats\").(string)\n                fmt.Println(ctxVal)\n\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(*tc.Response(), resp.Body)\n                return err\n            },\n            Middlewares: []tupa.MiddlewareFunc{MiddlewareSampleRoute},\n        },\n    }\n}\n\n</code></pre> <p>output:</p> <pre><code>context.Background.WithValue(type *http.contextKey, val &lt;not Stringer&gt;).WithValue(type *http.contextKey, val [::1]:6969).WithCancel.WithCancel.WithValue(type mux.contextKey, val &lt;not Stringer&gt;).WithValue(type mux.contextKey, val &lt;not Stringer&gt;).WithValue(type string, val contexto de algu\u00e9m interessado em gatos)\ncontexto de algu\u00e9m interessado em gatos\ncontexto de algu\u00e9m interessado em gatos\n</code></pre>"},{"location":"contributing/","title":"Guia de contribui\u00e7\u00e3o","text":"<p>Abra uma issue no reposit\u00f3rio do github e envie uma pull-request em uma branch separada. Crie uma branch com o nome da tag da vers\u00e3o do bug. Basta olhar a vers\u00e3o da \u00faltima tag no reposit\u00f3rio.</p>"},{"location":"contributing/#repositorio","title":"Reposit\u00f3rio","text":"<p>Github tupa</p>"},{"location":"examples/","title":"Exemplos","text":"<p>Em breve mais exemplos</p>"},{"location":"getting_started/","title":"Como funciona o registro de rotas","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>Registro Simples</li> <li>Registro de mais rotas</li> <li>Second Item</li> </ul> <p></p>"},{"location":"getting_started/#registro-simples","title":"Registro simples","text":"<p>De forma simples, podemos instanciar uma rota ao chamar o m\u00e9todo <code>RegisterRoutes([]tupa.RouteInfo{routeInfo})</code>, que podemos acessar facilmente a partir do nosso servidor instanciado.</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    routeInfo := tupa.RouteInfo{\n        Path:   \"/\",\n        Method: \"GET\",\n        Handler: func(tc *tupa.TupaContext) error {\n            return tupa.WriteJSONHelper(*tc.Response(), http.StatusOK, \"Hello world! :D\")\n        },\n    }\n    server.RegisterRoutes([]tupa.RouteInfo{routeInfo})\n\n    server.New()\n}\n</code></pre> <p>Agora em <code>http://localhost:6969/</code>iremos obter a mensagem \"Hello world! :D\".</p> <p>No Tup\u00e3, por padr\u00e3o todo handler deve receber um TupaContext e retornar um erro. Atrav\u00e9s do TupaContext voc\u00ea ser\u00e1 capaz de acessar diversas funcionalidades para a sua requisi\u00e7\u00e3o ser bem sucedida.</p> <p></p>"},{"location":"getting_started/#registro-de-mais-rotas","title":"Registro de mais rotas","text":"<p>Para fazer o registro de novas rotas, podemos simplesmente adicionar mais paths ao array <code>routeInfo</code></p> <pre><code>package main\n\nimport (\n    \"io\"\n    \"net/http\"\n\n    \"github.com/tupatech/tupa\"\n)\n\nfunc main() {\n    server := tupa.NewAPIServer(\":6969\")\n    routeInfo := []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(*tc.Response(), http.StatusOK, \"Hello world! :D\")\n            },\n        },\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(*tc.Response(), resp.Body)\n                return err\n            },\n        },\n    }\n\n    server.RegisterRoutes(routeInfo)\n    server.New()\n}\n\n</code></pre> <p>Agora teremos os dois endpoints registrados, se <code>/</code>e <code>/cats</code>. Se formos em <code>http://localhost:6969/cat</code> vamos ver a foto de um \ud83d\udc08.</p> <p>Por\u00e9m, em alguns casos vamos precisar registrar rotas com regras diferentes, para isso devemos usar os middlewares. </p>"},{"location":"license/","title":"Licen\u00e7a","text":"<pre><code>MIT License\n\nCopyright (c) 2024 Victor Hugo Gabriel dos Reis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Tabela de conte\u00fados:</p> <ul> <li>MIddlewares simples</li> <li>Middlewares diferentes para Conjuntos de rotas</li> <li>Middlewares em conjuntos de rotas + especificos de rotas</li> </ul> <p>Usar middlewares no Tup\u00e3 \u00e9 muito f\u00e1cil, podemos implementar middlewares tanto a n\u00edvel de rota quando para conjuntos de rotas. </p> <p></p>"},{"location":"middlewares/#middlewares-simples","title":"Middlewares simples","text":"<p>Vamos adicionar um middleware simples a n\u00edvel de rota. Basta adicionar uma nova propriedade <code>Middlewares</code> dentro do objeto do endpoint.</p> <p>Vamos adicionar um middleware na rota <code>/cats</code>.</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    routeInfo := []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(*tc.Response(), http.StatusOK, \"Hello world! :D\")\n            },\n        },\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(*tc.Response(), resp.Body)\n                return err\n            },\n            Middlewares: []tupa.MiddlewareFunc{\n                MiddlewareSampleCats,\n            },\n        },\n    }\n\n    server.RegisterRoutes(routeInfo)\n    server.New()\n}\n\nfunc MiddlewareSampleCats(next tupa.APIFunc) tupa.APIFunc {\n    return func(tc *tupa.TupaContext) error {\n        tc.Resp.Header().Set(\"Content-Type\", \"image/jpeg\")\n        tc.Resp.Header().Add(\"Referrer-Policy\", \"alguem interessado em gatos\")\n        return next(tc)\n    }\n}\n</code></pre> <p>Podemos obter o resultado do middleware acima, basta apertar f12 e conferir a requisi\u00e7\u00e3o na aba Network do nosso devtools.</p> <p></p> <p></p>"},{"location":"middlewares/#conjuntos-de-rotas-com-middlewares-diferentes","title":"Conjuntos de rotas com middlewares diferentes","text":"<p>Mas pode ser que queremos adicionar middlewares diferentes para conjuntos de rotas diferentes. Nesse caso podemos armazenar nossas rotas em fun\u00e7\u00f5es e chamar o m\u00e9todo <code>GetRoutes()</code> do Tup\u00e3 como par\u00e2metro a fun\u00e7\u00e3o RegisterRoutes(). Veja um exemplo abaixo:</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    exampleManager()\n    server.RegisterRoutes(tupa.GetRoutes())\n    server.New()\n}\n\nfunc MiddlewareSampleCats(next tupa.APIFunc) tupa.APIFunc {\n    return func(tc *tupa.TupaContext) error {\n        tc.Resp.Header().Set(\"Content-Type\", \"image/jpeg\")\n        tc.Resp.Header().Add(\"Referrer-Policy\", \"alguem interessado em gatos\")\n        return next(tc)\n    }\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(nil, SampleViewsManager)\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc SampleViewsManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(*tc.Response(), http.StatusOK, \"Hello world! :D\")\n            },\n        },\n    }\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(*tc.Response(), resp.Body)\n                return err\n            },\n        },\n    }\n}\n</code></pre> <p>Esse c\u00f3digo vai colocar nosso middleware como anteriormente, por\u00e9m agora est\u00e1 adicionando em um escopo maior, ao inv\u00e9s de ser um middleware de rota ele agora \u00e9 um middleware que age sobre um conjunto de rotas. Dessa forma podemos passar quantas rotas quisermos para um middleware espec\u00edfico.</p> <p></p>"},{"location":"middlewares/#middlewares-em-conjuntos-de-rotas-rota-especifica","title":"Middlewares em conjuntos de rotas + rota espec\u00edfica","text":"<p>Podemos tamb\u00e9m adicionar os middlewares para conjuntos de rotas e espec\u00edficos de rota juntos. Nesse caso a ordem ser\u00e1 que os especificos de rota ter\u00e3o preced\u00eancia sobre os de grupo na execu\u00e7\u00e3o. Vejamos no c\u00f3digo a seguir:</p> <pre><code>func main() {\n    server := tupa.NewAPIServer(\":6969\")\n    exampleManager()\n    server.RegisterRoutes(tupa.GetRoutes())\n    server.New()\n}\n\nfunc MiddlewareSampleCats(next tupa.APIFunc) tupa.APIFunc {\n    return func(tc *tupa.TupaContext) error {\n        fmt.Println(\"Printado depois\")\n        return next(tc)\n    }\n}\n\nfunc MiddlewareSampleRoute(next tupa.APIFunc) tupa.APIFunc {\n    return func(tc *tupa.TupaContext) error {\n        fmt.Println(\"Printado antes\")\n        tc.Resp.Header().Set(\"Content-Type\", \"text/plain\")\n        tc.Resp.Header().Add(\"Referrer-Policy\", \"alguem interessado em gatos\")\n        return next(tc)\n    }\n}\n\nfunc exampleManager() {\n    tupa.AddRoutes(nil, SampleViewsManager)\n    tupa.AddRoutes(tupa.MiddlewareChain{MiddlewareSampleCats}, SampleRouteManager)\n}\n\nfunc SampleViewsManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                return tupa.WriteJSONHelper(*tc.Response(), http.StatusOK, \"Hello world! :D\")\n            },\n        },\n    }\n}\n\nfunc SampleRouteManager() []tupa.RouteInfo {\n    return []tupa.RouteInfo{\n        {\n            Path:   \"/cats\",\n            Method: \"GET\",\n            Handler: func(tc *tupa.TupaContext) error {\n                resp, err := http.Get(\"https://cdn2.thecatapi.com/images/dN6eoeLjY.jpg\")\n                if err != nil {\n                    return err\n                }\n                defer resp.Body.Close()\n                _, err = io.Copy(*tc.Response(), resp.Body)\n                return err\n            },\n            Middlewares: []tupa.MiddlewareFunc{MiddlewareSampleRoute},\n        },\n    }\n}\n</code></pre> <p>Ouput:</p> <pre><code>Servidor iniciado na porta: :6969\nPrintado antes\nPrintado depois\n</code></pre>"}]}